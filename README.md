# golang_programming_essence
Go言語プログラミングエッセンス

## 第2章
* 「The Go1 Compatibility Rules」
    * このルールに基づいて、Go言語では下位互換性が保たれている（=古いバージョンでも動作可能）
    * 従って、pyenvのような別々に管理可能なパッケージ管理ツールは導入しなくても良い

## 第3章
* 配列やスライスをイミュータブルにすることができない
* 変数宣言時に先頭を`var`から始めることで、コンパイルに優しい設計
* エラーが発生する関数は、基本的には即座に返す
    * あとでまるっと返さない（pythonでいうraiseに近いイメージ？）
* switch文において、caseはインデントを下げずにswitchと同じ高さで記述
* Labeled Breakと呼ばれる記法を使うと、多重for文のネスト部分から一気に外側まで抜けられる
* stringはイミュータブルなので、文字列の一部を変換するためにはバイト列に変換する必要がある
    * 出力する場合は、一部だけもOK
* 文字列はダブルクォートorバッククォートで囲む
    * シングルクォートは、rune型と呼ばれる変わった型になる
    * rune型を使って、string型の一部を変換することも可能
        * ただし、stringがイミュータブルなため、再代入が必要
* structのフィールド名は大文字から始める
    * 小文字から始めるとエラーではなく、無視される
* switch-case文では、typeで定義された型を扱うことができない
    * ビルトインな型のみswitch-caseで調べることが可能
    * 厳密には、`reflect`パッケージを使うことで扱うことができる
* 1.18から、interface{}はanyに置き換えても、同じ動作をする
    * こういうのが、さっき出てきた下位互換性に繋がってくるのか
* `defer`は関数の実行完了時に呼び出される
    * for文の中で実行したとしても、都度繰り返し実行されたりしない
* gorutineを実行するには、実行する関数の前に`go `とつけるだけ
    * 無名関数と組み合わせると、実行順が想定外になる可能性がある
    * これを`race condition`と呼び、データの競合が起きている
    * `go build -race main.go`のように`race`オプションをつけると検出可能
* gorutineとchannel（チャネル）を組み合わせることで、より効率的に並行処理が可能
* `select`文を使うことで、channelの処理を複数行いたい時に制御できる
    * channel1とchannel2がそれぞれデータを持ってきたときに処理する、的な
* ダック・タイピング
    * いまいちピンと来なかったので、一旦後回し

## 第4章
* `recover`はdeferの中で呼び出す必要がある
    * defer+無名関数の組み合わせで、その無名関数にrecover時の処理を記述
    * 基本的にはpanic-recoverは乱用せずに、事前にエラーの可能性を考慮しておく
        * 起きるべくして起きるエラーのみをrecoverする
* `Explicit is better than implicit`, `Simple is better than complex`
    * The Zen of Pythonより引用とのこと
* init()関数は、呼び出された最初だけ実行される特殊な関数
* ブランクimportと呼ばれる、import時に`_ [モジュール名]`のように先頭にアンダースコアがつくimportの形式
    * 呼び出した側で明示的に使われないモジュール名だが、実行時には呼び出しておく必要があるときに使われる
    * モジュールを呼び出す必要があるが、コード内で未使用だとエラーになるとき、などに有効
* log出力は、info/warning/errorのようなログレベルはないので、必要に応じてサードパーティのライブラリを使う
    * log.Fatal系のログ出力機能は、プログラムの強制終了も兼ねている
* jsonを扱う際は、structでタグと呼ばれるメタ情報を付加できる
    * pythonで言うところの、pydanticを使った型定義みたいな
* timeモジュールが特徴的
    * `2006/01/02 15:04:05`のように、`yyyy/MM/dd HH:mm:ss`が連番で1~6になっている
    * ゼロ埋めするなら`01`になり、24時間表記にするならHHを24進数表記にする
* `path`パッケージはURLパスで、`path/filepath`パッケージは物理的なパスに使用するように使い分けが必要
    * `path`パッケージはURLを扱うので`/`で区切れるが、物理的なパスはOSによって区切れ文字が異なるため`path/filepath`を使う
* 基本的にはgorutine自身が制御の主導権を持つが、gorutine以外で制御したい場合は`context`パッケージが有効
* goファイルの先頭に`//go: build [タグ名]`をつけることで、使用するOS環境に応じたビルドが区別できる
    * package指定と本コメントは必ず1行空行が必要
    * 例：`//go: build linux && arm`
    * 自身で作成したgoファイルを指定することも可能
    `//go: build ignore`という特殊なタグがあり、これはサンプルコードとしてmain.goを複数おく時によく利用される
        * このファイルを実行する際には、`go build [ファイル名].go`のように直接指定すればOK
* `//go:embed [パス名]`というマジックコメントをgoファイル内で使用すると、ビルド時に一緒に他のファイルを埋め込んでくれる
    * "embed"パッケージをブランクimportする必要あり
    * 通常ビルドする時はgoファイルのみ差分を検知するので、画像やテキストといったgo以外のファイルを埋め込むことで、その差分も反映できる
* Functional Options Patternによって、オプションである複数の任意の引数に対するバリデーションが可能
    * 構造体に必須/任意の引数は用意しておく
        * goには引数のデフォルト値を設定する機能がないため、構造体の中で初期値を設けておく
    * `With[XXX]`の命名規則に従って、オプションの引数に関するバリデーションを実施する
        * 返り値はクロージャ
        * `With[XXX]`はデファクトスタンダードであり、別にWithから始めないと動かないとかではない
    * オプション引数の引数が充実していないことを考慮すると、よっぽどのことでない限りは実装しない方が良いのかもしれない？
* `internal`パッケージを使うと、自作ライブラリのimportを制限できる
    * internalフォルダと同列 or その配下にある場合はimport可能だが、internalフォルダより上の階層からはimportできなくなる
    * internalパッケージと呼称されているが、`package main`みたいなpackageとは違ってあくまで仕組み名らしい
* (__感想__)
    * 知らないことがたくさんあって、工夫の仕方が色々わかった __気がする__
        * 完全に理解できているわけじゃないので、ゆっくり必要に応じて思い出せると良いかな
    * 普段pythonしか触ってないこともあって、goの考え方や概念がピンと来てない箇所もあるので、そこも追い追い詰める

---
    
## その他メモ
* `$ go mod init [アプリ名]`
    * モジュールの初期化
* `$ go install [モジュール名（or githubのURLなど）]`
    * `$ go get [モジュール名]`はgo.modを変更するが、installの場合はgo.modには触れない
    * プログラム側で新規の外部モジュールを使う場合は、依存関係を明らかにするためにgo.modを更新する必要がある
        * pythonで言うと、外部モジュール使うためにinstallするのと同じか
* `$ go mod tidy`
    * パッケージの追加/削除を行なってごちゃごちゃになったときに、整理してくれる
    * パッケージの依存関係に基づいて、当初のバージョンが変わったりすることがあるので、`$ go mod edit -go=[バージョン]`のように修正する
* `$ go mod vendor`
    * vendorディレクトリにモジュールがダウンロードされる
    * buildする際に、vendorディレクトリ配下のモジュールが優先して参照される
        * ネットワーク環境がないときにインストールしたりできる
* `$ go vet`
    * golangにおける静的解析を実行する
    * golangはコンパイル時に、成功 or 失敗の判断しかなく、警告は出ない
* 作業ディレクトリ内のgoのバージョンを上げるには、インストールしている環境のバージョン以下である必要がある
