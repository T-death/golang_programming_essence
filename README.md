# golang_programming_essence
Go言語プログラミングエッセンス

## 第2章
* 「The Go1 Compatibility Rules」
    * このルールに基づいて、Go言語では下位互換性が保たれている（=古いバージョンでも動作可能）
    * 従って、pyenvのような別々に管理可能なパッケージ管理ツールは導入しなくても良い

## 第3章
* 配列やスライスをイミュータブルにすることができない
* 変数宣言時に先頭を`var`から始めることで、コンパイルに優しい設計
* エラーが発生する関数は、基本的には即座に返す
    * あとでまるっと返さない（pythonでいうraiseに近いイメージ？）
* switch文において、caseはインデントを下げずにswitchと同じ高さで記述
* Labeled Breakと呼ばれる記法を使うと、多重for文のネスト部分から一気に外側まで抜けられる
* stringはイミュータブルなので、文字列の一部を変換するためにはバイト列に変換する必要がある
    * 出力する場合は、一部だけもOK
* 文字列はダブルクォートorバッククォートで囲む
    * シングルクォートは、rune型と呼ばれる変わった型になる
    * rune型を使って、string型の一部を変換することも可能
        * ただし、stringがイミュータブルなため、再代入が必要
* structのフィールド名は大文字から始める
    * 小文字から始めるとエラーではなく、無視される
* switch-case文では、typeで定義された型を扱うことができない
    * ビルトインな型のみswitch-caseで調べることが可能
    * 厳密には、`reflect`パッケージを使うことで扱うことができる
* 1.18から、interface{}はanyに置き換えても、同じ動作をする
    * こういうのが、さっき出てきた下位互換性に繋がってくるのか
* `defer`は関数の実行完了時に呼び出される
    * for文の中で実行したとしても、都度繰り返し実行されたりしない
* gorutineを実行するには、実行する関数の前に`go `とつけるだけ
    * 無名関数と組み合わせると、実行順が想定外になる可能性がある
    * これを`race condition`と呼び、データの競合が起きている
    * `go build -race main.go`のように`race`オプションをつけると検出可能
* gorutineとchannel（チャネル）を組み合わせることで、より効率的に並行処理が可能
* `select`文を使うことで、channelの処理を複数行いたい時に制御できる
    * channel1とchannel2がそれぞれデータを持ってきたときに処理する、的な
* ダック・タイピング
    * いまいちピンと来なかったので、一旦後回し

---
    
## その他メモ
* `$ go mod init [アプリ名]`
    * モジュールの初期化
* `$ go install [モジュール名（or githubのURLなど）]`
    * `$ go get [モジュール名]`はgo.modを変更するが、installの場合はgo.modには触れない
    * プログラム側で新規の外部モジュールを使う場合は、依存関係を明らかにするためにgo.modを更新する必要がある
        * pythonで言うと、外部モジュール使うためにinstallするのと同じか
* `$ go mod tidy`
    * パッケージの追加/削除を行なってごちゃごちゃになったときに、整理してくれる
    * パッケージの依存関係に基づいて、当初のバージョンが変わったりすることがあるので、`$ go mod edit -go=[バージョン]`のように修正する
* `$ go mod vendor`
    * vendorディレクトリにモジュールがダウンロードされる
    * buildする際に、vendorディレクトリ配下のモジュールが優先して参照される
        * ネットワーク環境がないときにインストールしたりできる
* `$ go vet`
    * golangにおける静的解析を実行する
    * golangはコンパイル時に、成功 or 失敗の判断しかなく、警告は出ない